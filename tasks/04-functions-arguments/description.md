Написать функцию `isInArray()`, которая принимает переменное количество аргументов. Возвращает `true`, если все аргументы, кроме последнего входят в последний. Последним всегда должен быть массив.

    isInArray(1, [1]); // true
    isInArray(1, 2, [1]); // false
    isInArray(1, 2, [1,2,2,2]); // true

----------

Написать функцию `extend()`, которая принимает аргументом любое количество объектов и возвращает новый объект, в котором собраны все свойства из переданных объектов.

    extend({foo: true}, {bar: false}); // -> {foo: true, bar: false}
    extend({}, {bar: false}); // -> {bar: false}

Значения имен свойств с одинаковым именем перезатираются в пользу тех, что встретились позже.

    extend({foo: true}, {foo: false}); // -> {foo: false}

----------

Написать функцию `every(arr, func)`, которая принимает аргументами массив и функцию, вызывает для каждого элемента массива функцию с аргументами `arr[i], i, arr`. Если для каждого `i`-ого элемента массива `func(arr[i], i, arr)` вернула `true`, `every` должна вернуть `true`.

    every([], function () {return true}); // true
    every([NaN, NaN], function (el) {return isNaN(el)}); // true
    every([NaN, 0], function (el) {return isNaN(el)}); // false
    every([1,2,3], function (el, i) {return el > i}); // true
    every([2,3,4], function (el, i) {return el < i}); // false

Решение должно работать в ie8

----------

Создай функцию с именем `summ`, которая возвращает сумму всех передаваемых ей аргументов. Функция должна отрабатывать с любыми входящими данными. Функция должна всегда возвращать число.

----------

Напиши функцию `parse(string)`, которая принимает аргументом query string, и возвращает объект. Типы данных, которые должны распознаваться: строки, числа (только целые), булевы.

    parse(''); // -> {}
    parse('test=10'); // -> {"test": 10}
    parse('test=bar'); // -> {"test": "bar"}
    parse('test=10&foo=bar'); // -> {"test": 10, foo: "bar"}