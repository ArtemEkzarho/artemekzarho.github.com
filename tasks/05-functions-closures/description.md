Написать функцию `getUnique(arr)`, которая принимает аргументом массив или массивоподобный объект, и возвращает массив уникальных элементов. Аргумент не должен изменяться. Порядок элементов результирующего массива должен совпадать с порядком, в котором они встречаются в оригинальной структуре.

Специально обрабатывать значение `NaN` не обязательно.

    var a = {};
    var b = {};
     
    var u = getUnique([a,b,b,a]);
    console.log(u[0] === a); // true
    console.log(u[1] === b); // true
    console.log(u.length === 2); // true

----------

Написать функцию `createCachable(func)`, принимающую аргументом функцию. `createCachable(func)` возвращает новую функцию, которая возвращает результат вызова `func` и запоминает его, или возвращает уже запомненный результат для текущего аргумента. Функция `func` может иметь только один аргумент. `createCachable(func)` может создавать какое угодно количество кешированных версий функций.

    // функция возвращает квадрат аргумента,
    // но выполняется секунду
    function longTimeMultiplier(num) {
      var now = new Date().getTime();
      while (new Date().getTime() < now + 1000);
      return num * num;
    }
    
    var cachableMultiplier = createCachable(longTimeMultiplier);
    
    // Первый вызов выполняется так же долго, как и оригинальная функция
    var mul10 = cachableMultiplier(10); 
    
    // Последующие вызовы с тем же аргументом моментальны
    var mul10_1 = cachableMultiplier(10);
    var mul10_2 = cachableMultiplier(10);
    var mul10_3 = cachableMultiplier(10);

----------

Написать функцию `createKeeper()`, которая возвращает объект с 2 методами `put(key, value)` и `get(key)`. Метод `get(key)` должен возвращать данные, которые были сохранены с помощью метода `put`, если вызывается с тем же значением `key`, что и `put`.

Ключами могут быть как объекты, так и примитивы, про NaN не задумываться.

Если `put` был вызван с таким ключом, с которым уже был вызван ранее, старое значение перезатирается новым.

Доступ к ключам и значениями должен быть возможен только через методы `put` и `get`.

    var keeper = createKeeper();
    var key1 = {};
    var key2 = {};
    var key1Copy = key1;
    
    keeper.put(key1, 999)
    keeper.put(key2, [1,2,3])
    console.log(keeper.get(key1)); // 999
    console.log(keeper.get(key2)); // [1,2,3]
    console.log(keeper.get(key1Copy)); // 999
    console.log(keeper.get({})); // null
    keeper.put(key1, key2);
    console.log(keeper.get(key1Copy) === key2); // true

----------

Написать функцию `createSummator(initialValue)`, с опциональным первым параметром, который является точкой отчета счетчика. Если аргумент `initialValue` не передан, то отчет начинается с `0`. При каждом вызове функция возвращает объект с методами `inc(num)`, `dec(num)`, `get()`. Объектов, которые возвращает функция `createSummator(initialValue)`, может быть любое количество.

Реализация должна позволять манипуляции со значением счетчика только с использованием этих методов.

- Вызов метода `inc(num)` увеличивает значение счетчика на значение аргумента `num`. Если метод вызван без аргумента, то значение счетчика увеличивается на `1`
- Вызов метода `dec(num)` уменьшает значение счетчика на значение `num`, если метод вызван с аргументом. Если метод вызван без аргумента, то значение счетчика уменьшается на `1`
- Вызов метода `get()` возвращает текущее значение счетчика.

Примеры использования:

    var s1 = createSummator();
    s1.inc();
    s1.inc();
    s1.inc();
    console.log(s1.get()); // 3
    
    var s2 = createSummator(10);
    s2.inc(2);
    s2.inc(3);
    s2.inc(4);
    console.log(s2.get()); // 19
    
    var s3 = createSummator(5);
    s3.inc(5);
    s3.dec(10);
    console.log(s3.get()); // 0
